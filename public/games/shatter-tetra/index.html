<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Shatter-Tetra</title>
    <style>
        :root {
            --bg-color: #050510;
            --neon-blue: #00f3ff;
            --neon-pink: #ff00ff;
            --neon-green: #00ff00;
            --neon-yellow: #ffff00;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: white;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            touch-action: none;
        }

        #game-layout {
            display: flex;
            gap: 20px;
        }

        #game-container {
            position: relative;
        }

        #game-canvas {
            display: block;
            box-shadow: 0 0 20px rgba(0, 243, 255, 0.2);
            border: 2px solid #333;
            background-color: rgba(0, 0, 0, 0.8);
        }

        #side-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        #next-piece-container,
        #score-container {
            width: 120px;
            background-color: rgba(0, 0, 0, 0.8);
            border: 2px solid #333;
            box-shadow: 0 0 10px rgba(0, 243, 255, 0.1);
            padding: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .panel-label {
            font-size: 14px;
            color: #aaa;
            text-transform: uppercase;
            margin-bottom: 10px;
        }

        .score-value {
            font-size: 24px;
            font-weight: bold;
            color: var(--neon-blue);
            text-shadow: 0 0 10px var(--neon-blue);
        }

        #next-canvas {
            background-color: transparent;
        }

        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            background: rgba(0, 0, 0, 0.9);
            padding: 20px 40px;
            border: 2px solid var(--neon-pink);
            box-shadow: 0 0 30px var(--neon-pink);
            border-radius: 8px;
            display: none;
            z-index: 10;
        }

        #game-over h2 {
            color: var(--neon-pink);
            margin: 0 0 10px 0;
            font-size: 32px;
            text-shadow: 0 0 10px var(--neon-pink);
        }

        #restart-btn {
            background: transparent;
            color: white;
            border: 1px solid white;
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            margin-top: 15px;
            transition: all 0.2s;
        }

        #restart-btn:hover {
            background: white;
            color: black;
            box-shadow: 0 0 15px white;
        }

        /* Mobile Controls */
        #mobile-controls {
            position: absolute;
            bottom: 20px;
            left: 0;
            width: 100%;
            height: 150px;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            padding: 0 20px;
            box-sizing: border-box;
            pointer-events: none;
            display: none;
        }

        @media (hover: none) and (pointer: coarse) {
            #mobile-controls {
                display: flex;
            }
        }

        .control-btn {
            width: 70px;
            height: 70px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            pointer-events: auto;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            color: white;
            user-select: none;
            backdrop-filter: blur(4px);
            touch-action: manipulation;
        }

        .control-btn:active {
            background: rgba(255, 255, 255, 0.3);
        }

        .d-pad {
            display: flex;
            gap: 10px;
        }

        .action-pad {
            display: flex;
            gap: 10px;
        }

        /* Mobile Layout Adjustments */
        @media (max-width: 600px) {
            body {
                align-items: flex-start;
                padding-top: 20px;
            }

            #game-layout {
                flex-direction: column-reverse;
                align-items: center;
                gap: 10px;
                transform: scale(0.85);
                transform-origin: top center;
            }

            #side-panel {
                flex-direction: row;
                width: 100%;
                justify-content: center;
                gap: 10px;
            }

            #next-piece-container,
            #score-container,
            #highscore-container {
                width: auto;
                min-width: 80px;
                padding: 5px;
            }

            #game-canvas {
                max-width: 95vw;
                height: auto;
            }
        }
    </style>
</head>

<body>
    <a href="/"
        style="position: fixed; top: 10px; left: 10px; z-index: 1000; padding: 10px 15px; background: rgba(0,0,0,0.7); color: white; border-radius: 8px; text-decoration: none; font-family: sans-serif; font-weight: bold; border: 1px solid rgba(255,255,255,0.3); backdrop-filter: blur(4px);">üè†
        Home</a>

    <div id="game-container">
        <div id="game-layout">
            <canvas id="game-canvas" width="320" height="640"></canvas>
            <div id="side-panel">
                <div id="next-piece-container">
                    <div class="panel-label">NEXT</div>
                    <canvas id="next-canvas" width="100" height="100"></canvas>
                </div>
                <div id="score-container">
                    <div class="panel-label">SCORE</div>
                    <div id="score" class="score-value">0</div>
                </div>
                <div id="highscore-container">
                    <div class="panel-label">BEST</div>
                    <div id="highscore" class="score-value"
                        style="color:var(--neon-yellow); text-shadow:0 0 10px var(--neon-yellow);">0</div>
                </div>
                <!-- Difficulty Display -->
                <div id="diff-display" style="text-align:center; color:#888; margin-top:10px;"></div>
            </div>
        </div>

        <div id="game-over">
            <h2>GAME OVER</h2>
            <p>Score: <span id="final-score">0</span></p>
            <p style="font-size:14px; color:#aaa; margin-top:-10px;">Best: <span id="final-best">0</span></p>
            <button id="restart-btn">RETRY</button>
            <button id="menu-btn"
                style="margin-top:10px; background:transparent; color:#aaa; border:1px solid #aaa; padding:5px 10px; cursor:pointer;">MENU</button>
        </div>

        <div id="start-screen">
            <h1
                style="color:var(--neon-blue); text-shadow:0 0 20px var(--neon-blue); margin-bottom:40px; font-size:40px;">
                SHATTER<br>TETRA</h1>
            <div class="diff-btn" data-diff="easy" style="border-color: #00ff00; color:#00ff00;">EASY</div>
            <div class="diff-btn" data-diff="normal" style="border-color: #ffff00; color:#ffff00;">NORMAL</div>
            <div class="diff-btn" data-diff="hard" style="border-color: #ffaa00; color:#ffaa00;">HARD</div>
            <div class="diff-btn" data-diff="veryhard" style="border-color: #ff0055; color:#ff0055;">VERY HARD</div>
        </div>

        <div id="mobile-controls">
            <div class="d-pad">
                <div class="control-btn" id="btn-left">‚Üê</div>
                <div class="control-btn" id="btn-right">‚Üí</div>
                <div class="control-btn" id="btn-down">‚Üì</div>
            </div>
            <div class="action-pad">
                <div class="control-btn" id="btn-rotate">‚Üª</div>
            </div>
        </div>
    </div>

    <style>
        /* Add Start Screen Styles */
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(5, 5, 16, 0.95);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 20;
        }

        .diff-btn {
            width: 200px;
            padding: 15px;
            margin: 10px;
            border: 2px solid white;
            text-align: center;
            font-weight: bold;
            font-size: 18px;
            cursor: pointer;
            transition: all 0.2s;
            background: rgba(0, 0, 0, 0.5);
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        .diff-btn:hover {
            transform: scale(1.05);
            background: rgba(255, 255, 255, 0.1);
        }

        /* Update Side Panel */
        #side-panel {
            gap: 15px;
        }

        #highscore-container {
            width: 120px;
            background-color: rgba(0, 0, 0, 0.8);
            border: 2px solid #333;
            box-shadow: 0 0 10px rgba(255, 255, 0, 0.1);
            padding: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
    </style>

    <script>
        /**
         * Shatter-Tetra
         * Core Game Logic (v6: High Score)
         */

        const COLS = 10;
        const ROWS = 20;
        const BLOCK_SIZE = 32;

        // Expanded Colors
        const COLORS = [
            null,
            '#FF0055', // Red
            '#00FF55', // Green
            '#0088FF', // Blue
            '#FFEE00', // Yellow
            '#AA00FF', // Purple (Normal+)
            '#00FFFF', // Cyan (Hard+)
            '#FF8800'  // Orange (Very Hard)
        ];

        // Shapes categorized by size (implicitly)
        const SHAPES = [
            [],
            // --- 4 Blocks (Tetrominoes) ---
            [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]], // I
            [[1, 1], [1, 1]], // O
            [[0, 1, 0], [1, 1, 1], [0, 0, 0]], // T
            [[0, 1, 1], [1, 1, 0], [0, 0, 0]], // S
            [[1, 1, 0], [0, 1, 1], [0, 0, 1]], // Z
            [[1, 0, 0], [1, 1, 1], [0, 0, 0]], // J
            [[0, 0, 1], [1, 1, 1], [0, 0, 0]], // L

            // --- 3 Blocks (Trominoes) ---
            [[0, 1, 0], [0, 1, 0], [0, 1, 0]], // I3
            [[0, 1, 0], [0, 1, 1], [0, 0, 0]], // L3

            // --- 2 Blocks (Dominos) ---
            [[0, 1, 0], [0, 1, 0], [0, 0, 0]], // I2

            // --- 5 Blocks (Pentominoes) - Subset ---
            [[0, 0, 0, 0, 0], [0, 0, 1, 0, 0], [0, 0, 1, 0, 0], [0, 0, 1, 0, 0], [0, 0, 1, 0, 0]], // I5
            [[0, 0, 0], [1, 1, 1], [1, 0, 1]], // U
            [[0, 1, 0], [1, 1, 1], [0, 1, 0]], // X
            [[0, 1, 1], [1, 1, 0], [0, 1, 0]], // F (approx)
            [[1, 1, 0], [0, 1, 1], [0, 0, 1]]  // W
        ];

        // Map indices for easier filtering
        // 1-7: Tetrominoes (4)
        // 8-9: Trominoes (3)
        // 10: Domino (2)
        // 11-15: Pentominoes (5)

        const DIFFICULTY = {
            easy: { colorCount: 4, minSize: 2, maxSize: 4, label: "Easy", id: "easy" },
            normal: { colorCount: 5, minSize: 2, maxSize: 4, label: "Normal", id: "normal" },
            hard: { colorCount: 5, minSize: 3, maxSize: 5, label: "Hard", id: "hard" },
            veryhard: { colorCount: 6, minSize: 3, maxSize: 5, label: "Very Hard", id: "veryhard" }
        };

        class Game {
            constructor() {
                this.canvas = document.getElementById('game-canvas');
                this.ctx = this.canvas.getContext('2d', { alpha: false });

                this.nextCanvas = document.getElementById('next-canvas');
                this.nextCtx = this.nextCanvas.getContext('2d', { alpha: true });

                this.score = 0;
                this.highScore = 0;
                this.gameOver = false;
                this.isResolving = false;
                this.particles = [];
                this.grid = this.createGrid(COLS, ROWS);

                this.diffSettings = DIFFICULTY.normal; // Default

                this.resize();
                window.addEventListener('resize', () => this.resize());
                document.addEventListener('keydown', (e) => this.handleInput(e));

                document.getElementById('restart-btn').addEventListener('click', () => this.reset());
                document.getElementById('menu-btn').addEventListener('click', () => this.showMenu());

                // Difficulty Buttons
                document.querySelectorAll('.diff-btn').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        const diff = e.target.getAttribute('data-diff');
                        this.startGame(diff);
                    });
                });

                this.bindTouchControls();

                // Wait for menu selection
                this.update = this.update.bind(this);
                // Don't start loop until game starts
                this.showMenu(); // Show menu on load
            }

            createGrid(cols, rows) {
                return Array.from({ length: rows }, () => Array(cols).fill(0));
            }

            resize() { /* Fixed */ }

            showMenu() {
                document.getElementById('start-screen').style.display = 'flex';
                document.getElementById('game-over').style.display = 'none';
                this.gameOver = true; // Stop updates
                this.running = false; // Ensure update loop is not running
            }

            startGame(diffKey) {
                this.diffSettings = DIFFICULTY[diffKey];
                document.getElementById('diff-display').innerText = this.diffSettings.label;

                // Load High Score
                this.highScore = this.loadHighScore(diffKey);
                document.getElementById('highscore').innerText = this.highScore;

                document.getElementById('start-screen').style.display = 'none';

                this.reset();
                if (!this.running) {
                    this.running = true;
                    requestAnimationFrame(this.update);
                }
            }

            loadHighScore(diffKey) {
                const key = `shatter-tetra-score-${diffKey}`;
                return parseInt(localStorage.getItem(key)) || 0;
            }

            saveHighScore() {
                const key = `shatter-tetra-score-${this.diffSettings.id}`;
                if (this.score > this.highScore) {
                    this.highScore = this.score;
                    localStorage.setItem(key, this.highScore);
                    document.getElementById('highscore').innerText = this.highScore;
                    return true; // New Record
                }
                return false;
            }

            reset() {
                this.grid = this.createGrid(COLS, ROWS);
                this.score = 0;
                this.gameOver = false;
                this.isResolving = false;
                this.dropInterval = 1000;
                this.startTime = Date.now();
                this.level = 1;
                this.particles = [];
                this.updateScore(0);

                this.nextPieceObj = this.generatePiece();
                this.spawnPiece();

                document.getElementById('game-over').style.display = 'none';
                this.ctx.fillStyle = '#050510';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
            }

            generatePiece() {
                // Filter shapes based on difficulty size constraints
                // 4 blocks: indices 1-7
                // 3 blocks: indices 8-9
                // 2 blocks: index 10
                // 5 blocks: indices 11+
                const validIndices = [];
                SHAPES.forEach((s, i) => {
                    if (i === 0) return;
                    // Count blocks to determine size
                    let size = 0;
                    s.forEach(row => row.forEach(val => { if (val) size++; }));
                    if (size >= this.diffSettings.minSize && size <= this.diffSettings.maxSize) {
                        validIndices.push(i);
                    }
                });

                const typeId = validIndices[Math.floor(Math.random() * validIndices.length)];
                const shapeTemplate = SHAPES[typeId];

                const colorLimit = this.diffSettings.colorCount;

                const shape = shapeTemplate.map(row =>
                    row.map(cell => cell ? Math.floor(Math.random() * colorLimit) + 1 : 0)
                );

                return { shape, typeId };
            }

            spawnPiece() {
                const pObj = this.nextPieceObj;
                this.piece = {
                    shape: pObj.shape,
                    x: Math.floor(COLS / 2) - Math.ceil(pObj.shape[0].length / 2),
                    y: 0
                };
                this.nextPieceObj = this.generatePiece();
                this.drawNextPiece();

                if (this.collide(this.grid, this.piece)) {
                    this.triggerGameOver();
                }
            }

            triggerGameOver() {
                this.gameOver = true;
                this.saveHighScore();

                document.getElementById('final-score').innerText = this.score;
                document.getElementById('final-best').innerText = this.highScore;
                document.getElementById('game-over').style.display = 'block';
            }

            // ... collide, update, pieceDrop, applyGravity, createExplosion, getConnectedGroup, sleep, draw, etc ...
            // Copying existing methods to maintain functionality

            collide(grid, piece) {
                const m = piece.shape;
                const o = piece;
                for (let y = 0; y < m.length; ++y) {
                    for (let x = 0; x < m[y].length; ++x) {
                        if (m[y][x] !== 0 && (grid[y + o.y] && grid[y + o.y][x + o.x]) !== 0) return true;
                    }
                }
                return false;
            }

            update(time = 0) {
                if (this.gameOver && document.getElementById('start-screen').style.display === 'none' && document.getElementById('game-over').style.display === 'none') {
                    // Should technically not happen if game loop stops, but for safety
                }

                if (this.running) requestAnimationFrame(this.update);

                // Pause if game over specific UI is up? No, keep rendering usually
                if (document.getElementById('start-screen').style.display !== 'none') return;
                if (this.gameOver) return;

                const deltaTime = time - this.lastTime;
                this.lastTime = time;

                const elapsed = Date.now() - this.startTime;
                const newLevel = Math.floor(elapsed / 30000) + 1;
                if (newLevel > this.level) {
                    this.level = newLevel;
                    this.dropInterval = Math.max(100, 1000 - (this.level - 1) * 100);
                }

                for (let i = this.particles.length - 1; i >= 0; i--) {
                    this.particles[i].update();
                    if (this.particles[i].life <= 0) this.particles.splice(i, 1);
                }

                if (!this.isResolving) {
                    this.dropCounter += deltaTime;
                    if (this.dropCounter > this.dropInterval) this.pieceDrop();
                }
                this.draw();
            }

            pieceDrop() {
                this.piece.y++;
                if (this.collide(this.grid, this.piece)) {
                    this.piece.y--;
                    this.lockPiece();
                }
                this.dropCounter = 0;
            }

            async lockPiece() {
                this.piece.shape.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value !== 0) this.grid[y + this.piece.y][x + this.piece.x] = value;
                    });
                });
                this.piece = null;
                this.isResolving = true;

                let changed = true;
                let chain = 0;

                while (changed) {
                    await this.sleep(150);
                    const gravityMoved = this.applyGravity();
                    this.draw();
                    await this.sleep(150);

                    const { cleared, count } = this.clearMatches(); // Modified signature

                    if (cleared) {
                        chain++;
                        // New Formula: (100 + (Count - 4) * 20) * (2^(Chain-1))
                        const base = 100 + (count - 4) * 20;
                        const multiplier = Math.pow(2, chain - 1);
                        const points = base * multiplier;

                        this.score += points;
                        this.updateScore(this.score);
                    }

                    changed = gravityMoved || cleared;
                }
                this.isResolving = false;
                this.spawnPiece();
            }

            applyGravity() {
                let moved = false;
                for (let x = 0; x < COLS; x++) {
                    let writeY = ROWS - 1;
                    for (let y = ROWS - 1; y >= 0; y--) {
                        if (this.grid[y][x] !== 0) {
                            if (y !== writeY) {
                                this.grid[writeY][x] = this.grid[y][x];
                                this.grid[y][x] = 0;
                                moved = true;
                            }
                            writeY--;
                        }
                    }
                }
                return moved;
            }

            clearMatches() {
                const visited = Array.from({ length: ROWS }, () => Array(COLS).fill(false));
                let toRemove = [];
                let totalCleared = 0;

                for (let y = 0; y < ROWS; y++) {
                    for (let x = 0; x < COLS; x++) {
                        if (this.grid[y][x] !== 0 && !visited[y][x]) {
                            const group = this.getConnectedGroup(x, y, visited);
                            if (group.length >= 4) {
                                toRemove = toRemove.concat(group);
                            }
                        }
                    }
                }

                totalCleared = toRemove.length;
                if (totalCleared > 0) {
                    toRemove.forEach(pos => {
                        const color = this.grid[pos.y][pos.x];
                        this.createExplosion(pos.x, pos.y, COLORS[color]);
                        this.grid[pos.y][pos.x] = 0;
                    });
                    return { cleared: true, count: totalCleared };
                }
                return { cleared: false, count: 0 };
            }

            createExplosion(x, y, color) {
                const px = x * BLOCK_SIZE + BLOCK_SIZE / 2;
                const py = y * BLOCK_SIZE + BLOCK_SIZE / 2;
                for (let i = 0; i < 10; i++) {
                    this.particles.push(new Particle(px, py, color));
                }
            }

            getConnectedGroup(startX, startY, visited) {
                const color = this.grid[startY][startX];
                const group = [];
                const queue = [{ x: startX, y: startY }];
                visited[startY][startX] = true;
                group.push({ x: startX, y: startY });

                while (queue.length > 0) {
                    const { x, y } = queue.shift();
                    const dirs = [[0, 1], [0, -1], [1, 0], [-1, 0]];
                    for (let d of dirs) {
                        const nx = x + d[0];
                        const ny = y + d[1];
                        if (nx >= 0 && nx < COLS && ny >= 0 && ny < ROWS) {
                            if (!visited[ny][nx] && this.grid[ny][nx] === color) {
                                visited[ny][nx] = true;
                                group.push({ x: nx, y: ny });
                                queue.push({ x: nx, y: ny });
                            }
                        }
                    }
                }
                return group;
            }

            sleep(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }

            draw() {
                this.ctx.fillStyle = '#050510';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                this.drawMatrix(this.ctx, this.grid, { x: 0, y: 0 });
                if (this.piece) this.drawMatrix(this.ctx, this.piece.shape, { x: this.piece.x, y: this.piece.y });
                this.particles.forEach(p => p.draw(this.ctx));
            }

            drawNextPiece() {
                this.nextCtx.clearRect(0, 0, this.nextCanvas.width, this.nextCanvas.height);
                if (!this.nextPieceObj) return;
                const shape = this.nextPieceObj.shape;
                const w = shape[0].length * 20;
                const h = shape.length * 20;
                const tx = (this.nextCanvas.width - w) / 2;
                const ty = (this.nextCanvas.height - h) / 2;
                shape.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value !== 0) this.drawBlockCtx(this.nextCtx, x, y, value, 20, tx, ty);
                    });
                });
            }

            drawMatrix(ctx, matrix, offset) {
                matrix.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value !== 0) this.drawBlockCtx(ctx, x + offset.x, y + offset.y, value, BLOCK_SIZE, 0, 0);
                    });
                });
            }

            drawBlockCtx(ctx, x, y, colorIndex, size, offX, offY) {
                if (!colorIndex) return;
                const color = COLORS[colorIndex];
                ctx.fillStyle = color;
                ctx.shadowBlur = 10;
                ctx.shadowColor = color;
                const px = x * size + offX;
                const py = y * size + offY;
                ctx.fillRect(px + 1, py + 1, size - 2, size - 2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.4)';
                ctx.fillRect(px + size * 0.15, py + size * 0.15, size - size * 0.3, size - size * 0.3);
                ctx.shadowBlur = 0;
            }

            handleInput(event) {
                if (this.gameOver || this.isResolving || document.getElementById('start-screen').style.display !== 'none') return;
                if (event.keyCode === 37) this.pieceMove(-1);
                else if (event.keyCode === 39) this.pieceMove(1);
                else if (event.keyCode === 40) this.pieceDrop();
                else if (event.keyCode === 38) this.pieceRotate();
            }

            pieceMove(dir) {
                this.piece.x += dir;
                if (this.collide(this.grid, this.piece)) this.piece.x -= dir;
            }

            pieceRotate() {
                const pos = this.piece.x;
                let offset = 1;
                this.rotate(this.piece.shape);
                while (this.collide(this.grid, this.piece)) {
                    this.piece.x += offset;
                    offset = -(offset + (offset > 0 ? 1 : -1));
                    if (offset > this.piece.shape[0].length) {
                        this.rotate(this.piece.shape, -1);
                        this.piece.x = pos;
                        return;
                    }
                }
            }

            rotate(matrix, dir = 1) {
                for (let y = 0; y < matrix.length; ++y) {
                    for (let x = 0; x < y; ++x) {
                        [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
                    }
                }
                if (dir > 0) matrix.forEach(row => row.reverse());
                else matrix.reverse();
            }

            bindTouchControls() {
                const addTouch = (id, fn) => {
                    const btn = document.getElementById(id);
                    if (btn) {
                        btn.addEventListener('touchstart', (e) => {
                            e.preventDefault();
                            if (!this.isResolving && !this.gameOver && document.getElementById('start-screen').style.display === 'none') fn();
                        }, { passive: false });
                        btn.addEventListener('mousedown', (e) => {
                            e.preventDefault();
                            if (!this.isResolving && !this.gameOver && document.getElementById('start-screen').style.display === 'none') fn();
                        });
                    }
                };

                addTouch('btn-left', () => this.pieceMove(-1));
                addTouch('btn-right', () => this.pieceMove(1));
                addTouch('btn-down', () => this.pieceDrop());
                addTouch('btn-rotate', () => this.pieceRotate());

                const container = document.getElementById('game-container');
                let touchStartX = 0;
                let touchStartY = 0;
                let lastMoveX = 0;
                let lastMoveY = 0;
                let isTap = true;

                container.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    if (this.gameOver || this.isResolving || document.getElementById('start-screen').style.display !== 'none') return;
                    const t = e.touches[0];
                    touchStartX = t.clientX;
                    touchStartY = t.clientY;
                    lastMoveX = t.clientX;
                    lastMoveY = t.clientY;
                    isTap = true;
                }, { passive: false });

                container.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    if (this.gameOver || this.isResolving || document.getElementById('start-screen').style.display !== 'none') return;
                    const t = e.touches[0];
                    const dx = t.clientX - lastMoveX;
                    const dy = t.clientY - lastMoveY;
                    const moveThreshold = 30;

                    if (Math.abs(t.clientX - touchStartX) > 10 || Math.abs(t.clientY - touchStartY) > 10) isTap = false;

                    if (dx > moveThreshold) { this.pieceMove(1); lastMoveX = t.clientX; }
                    else if (dx < -moveThreshold) { this.pieceMove(-1); lastMoveX = t.clientX; }

                    if (dy > moveThreshold) { this.pieceDrop(); lastMoveY = t.clientY; }

                }, { passive: false });

                container.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    if (this.gameOver || this.isResolving || document.getElementById('start-screen').style.display !== 'none') return;
                    if (isTap) this.pieceRotate();
                });
            }

            updateScore(newScore) {
                this.score = newScore;
                const scoreEl = document.getElementById('score');
                if (scoreEl) scoreEl.innerText = this.score;
            }
        }

        class Particle {
            constructor(x, y, color) {
                this.x = x;
                this.y = y;
                this.color = color;
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 2 + 1;
                this.vx = Math.cos(angle) * speed;
                this.vy = Math.sin(angle) * speed;
                this.life = 1.0;
                this.decay = Math.random() * 0.03 + 0.02;
            }

            update() {
                this.x += this.vx;
                this.y += this.vy;
                this.vy += 0.1;
                this.life -= this.decay;
            }

            draw(ctx) {
                ctx.globalAlpha = this.life;
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
                ctx.fill();
                ctx.globalAlpha = 1.0;
            }
        }

        window.onload = () => {
            window.game = new Game();
        };

    </script>
</body>

</html>